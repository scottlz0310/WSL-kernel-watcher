# インストーラと自動更新の計画 (3.0.0 以降)

## 背景とゴール
- 3.0.0 時点の配布物はビルド成果物の Zip のみ。エンドユーザーにとってインストールと自動起動設定が手間。
- タスクスケジューラ登録と起動モード切替（通常/トレイ）を簡便にする薄いインストーラを用意し、将来の自動更新にも備える。

## 基本方針
- アーキテクチャ: x64 のみ。MSIX は避け、EXE/MSI ベースの軽量インストーラ。
- 責務の最小化: バイナリ展開、ショートカット作成、自動起動タスク登録の ON/OFF のみ。起動モード（--tray）はアプリ設定で持つ。
- 更新の段階的導入:
  - Phase 1: 起動時に GitHub Releases をチェックし、最新版があればダイアログでブラウザダウンロードを促す（安全優先）。
  - Phase 2: 専用アップデータ EXE を同梱し、アプリ終了→アップデータによる置換→タスク再登録まで自動化（余力・需要に応じて）。
- ツール選定: まずは PowerShell スクリプト（install/uninstall）をラップしたシンプルな EXE/MSI。将来、自動更新まで踏み込みたくなったら Velopack（Squirrel系後継）への移行を検討。

## スコープ
- インストーラ UI での自動起動登録 ON/OFF（デフォルト ON）
- ショートカット作成（スタートメニュー + 任意でデスクトップ）
- 起動モード設定はアプリ設定/設定ファイル側で切替（インストーラは分岐しない）
- 更新チェック: 起動時に GitHub Releases の最新タグを取得し、プリリリース除外で比較。新しければ通知ダイアログを表示し、ブラウザで最新版ページを開く。

## 非スコープ（Phase 2 以降の検討項目）
- 完全自動更新（アップデータによる自己更新とロールバック）
- ARM ビルド
- MSIX 配布

## タスク分解
### A. インストーラ最小版（Phase 1） ※完了
1. インストーラプロジェクト作成（EXE/MSI、x64 固定）
2. バイナリ配置先選択とショートカット作成
3. install.ps1 を呼び出す CustomAction でタスク登録（--tray 固定）／uninstall で解除
4. CI に x64 インストーラ生成ステップ追加、リリースアセットに含める
5. ドキュメント更新（README/CHANGELOG、配布手順）

### A'. インタラクティブインストーラ（Phase 2 で検討）
- 自己解凍 or 単一 EXE のセットアップ UI を提供し、タスク登録・ショートカット作成・トレイ起動設定をウィザード化する
- zip 二重化を解消し、「ダウンロードして即実行」の導線を整備
- アップデータ(EXE)を流用して、将来の自動更新フローに統合できる構成を検討

### B. 更新チェック（Phase 1）
1. 起動時に GitHub Releases 最新版を取得（プリリリース除外、タイムアウト/リトライを設定）
2. バージョン比較（アプリバージョン vs 最新タグ）
3. ダイアログ提示（今すぐブラウザで開く/後で/このバージョンをスキップ）
4. スキップバージョンの永続化（設定ファイル）
5. リリースノートへの導線（Release ページを開く）
6. テスト追加（API モックで比較・スキップ動作）

### C. 将来の Phase 2 準備（記録のみ）
- アップデータ EXE の設計（本体終了→差し替え→タスク再登録）
- Velopack への移行検討ポイントを別ドキュメント化

## 留意点
- ネットワーク失敗時は静かにスキップし、起動を妨げない。
- タスクスケジューラ登録に失敗した場合はログとダイアログで通知し、アプリ内から再登録できる動線を残す。
- セキュリティ: ダウンロード時は HTTPS + ハッシュ確認（checksums.txt）を案内。Phase 2 で自動検証を検討。
